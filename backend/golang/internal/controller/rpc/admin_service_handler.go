package controller

import (
	"context"

	"connectrpc.com/connect"
	"github.com/itsuabush1003/cursed-frame/backend/golang/internal/core"
	adminv1 "github.com/itsuabush1003/cursed-frame/backend/golang/internal/gen/admin/v1"        // generated by protoc-gen-go
	"github.com/itsuabush1003/cursed-frame/backend/golang/internal/gen/admin/v1/adminv1connect" // generated by protoc-gen-connect-go
	commonv1 "github.com/itsuabush1003/cursed-frame/backend/golang/internal/gen/common/v1"
	"github.com/itsuabush1003/cursed-frame/backend/golang/internal/model"
	"github.com/itsuabush1003/cursed-frame/backend/golang/internal/usecase"
	"google.golang.org/protobuf/types/known/emptypb"
)

type AdminServiceHandler struct {
	adminv1connect.UnimplementedAdminServiceHandler
	oeu  *usecase.OpenEntryUsecase
	ceu  *usecase.CloseEntryUsecase
	ruu  *usecase.RejectUserUsecase
	ctu  *usecase.ChangeTeamUsecase
	asqu *usecase.AdminStartQuestUsecase
	cau  *usecase.CheckAnswersUsecase
	nqu  *usecase.NextQuizUsecase
	equ  *usecase.EndQuestUsecase
}

func (ash *AdminServiceHandler) OpenEntry(ctx context.Context, r *connect.Request[emptypb.Empty], stream *connect.ServerStream[adminv1.OpenEntryResponse]) error {
	if err := ash.oeu.Execute(
		ctx,
		func(users []model.User) error {
			enteredUsers := make([]*adminv1.User, 0, len(users))
			for _, u := range users {
				enteredUsers = append(enteredUsers, &adminv1.User{
					UserId:   u.GetUserID().String(),
					UserName: u.GetName(),
					TeamId:   uint32(u.GetTeamID()),
					IsReady:  u.GetIsReady(),
				})
			}
			return stream.Send(&adminv1.OpenEntryResponse{EnteredUsers: enteredUsers})
		},
		func() { /*** DO NOTHING ***/ },
		func(err error) error {
			return connect.NewError(connect.CodeCanceled, err)
		},
	); err != nil {
		return connect.NewError(connect.CodeInternal, err)
	}
	return nil
}

func (ash *AdminServiceHandler) CloseEntry(ctx context.Context, r *connect.Request[emptypb.Empty]) (*connect.Response[emptypb.Empty], error) {
	if err := ash.ceu.Execute(); err != nil {
		return nil, connect.NewError(connect.CodeInvalidArgument, err)
	}
	return connect.NewResponse(&emptypb.Empty{}), nil
}

func (ash *AdminServiceHandler) RejectUser(ctx context.Context, r *connect.Request[adminv1.RejectUserRequest]) (*connect.Response[emptypb.Empty], error) {
	targetUserID := r.Msg.UserId
	if err := ash.ruu.Execute(targetUserID); err != nil {
		return nil, connect.NewError(connect.CodeInternal, err)
	}
	return connect.NewResponse(&emptypb.Empty{}), nil
}

func (ash *AdminServiceHandler) ChangeTeam(ctx context.Context, r *connect.Request[adminv1.ChangeTeamRequest]) (*connect.Response[emptypb.Empty], error) {
	targetUserID := r.Msg.UserId
	newTeamID := r.Msg.NewTeamId
	if err := ash.ctu.Execute(targetUserID, uint32(newTeamID)); err != nil {
		return nil, connect.NewError(connect.CodeInvalidArgument, err)
	}
	return connect.NewResponse(&emptypb.Empty{}), nil
}

func (ash *AdminServiceHandler) StartQuest(ctx context.Context, r *connect.Request[emptypb.Empty], stream *connect.ServerStream[adminv1.StartQuestResponse]) error {
	if err := ash.asqu.Execute(
		ctx,
		func(quiz core.Quiz, hint string) error {
			choices := make([]*commonv1.Choice, 0, len(quiz.Choices))
			for _, c := range quiz.Choices {
				choices = append(choices, &commonv1.Choice{
					ChoiceId:   uint32(c.ChoiceID),
					ChoiceText: c.ChoiceText,
				})
			}
			return stream.Send(&adminv1.StartQuestResponse{
				TargetUserImageId: quiz.ImageID,
				TargetTeamId:      uint32(quiz.TeamID),
				QuestionId:        uint32(quiz.QuestionID),
				Question:          quiz.QuestionText,
				Choices:           choices,
				LastTime:          int32(quiz.RemainedTime),
				HintText:          hint,
			})
		},
		func(err error) error {
			return connect.NewError(connect.CodeCanceled, err)
		},
	); err != nil {
		return connect.NewError(connect.CodeInternal, err)
	}
	return nil
}

func (ash *AdminServiceHandler) CheckAnswers(ctx context.Context, r *connect.Request[emptypb.Empty]) (*connect.Response[adminv1.CheckAnswersResponse], error) {
	results, err := ash.cau.Execute()
	if err != nil {
		return nil, connect.NewError(connect.CodeUnimplemented, err)
	}
	answers := make([]*adminv1.TeamAnswer, 0, len(results))
	for tid, res := range results {
		answers = append(answers, &adminv1.TeamAnswer{
			TeamId: uint32(tid),
			Answer: &commonv1.Choice{
				ChoiceId:   uint32(res.Answer.ChoiceID),
				ChoiceText: res.Answer.ChoiceText,
			},
			IsCorrect: res.IsCorrect,
		})
	}
	return connect.NewResponse(&adminv1.CheckAnswersResponse{
		Answers: answers,
	}), nil
}

func (ash *AdminServiceHandler) NextQuiz(ctx context.Context, r *connect.Request[emptypb.Empty]) (*connect.Response[emptypb.Empty], error) {
	if err := ash.nqu.Execute(); err != nil {
		return nil, connect.NewError(connect.CodeUnimplemented, err)
	}
	return connect.NewResponse(&emptypb.Empty{}), nil
}

func (ash *AdminServiceHandler) EndQuest(ctx context.Context, r *connect.Request[emptypb.Empty]) (*connect.Response[adminv1.EndQuestResponse], error) {
	resultState, teamStats, err := ash.equ.Execute()
	if err != nil {
		return nil, connect.NewError(connect.CodeInternal, err)
	}

	wholeStats := make([]*adminv1.TeamStats, 0, len(teamStats))
	for tid, stats := range teamStats {
		membersStats := make([]*adminv1.UserStats, 0, len(stats.MembersStats))
		for _, userStats := range stats.MembersStats {
			membersStats = append(membersStats, &adminv1.UserStats{
				UserName:      userStats.UserName,
				CorrectRate:   userStats.CorrectRate,
				PersonalOrder: userStats.PersonalOrder,
			})
		}
		wholeStats = append(wholeStats, &adminv1.TeamStats{
			TeamId:          uint32(tid),
			MembersStats:    membersStats,
			TeamCorrectRate: stats.CorrectRate,
			TeamOrder:       stats.TeamOrder,
		})
	}

	return connect.NewResponse(&adminv1.EndQuestResponse{
		Result: commonv1.Result(resultState),
		Stats:  wholeStats,
	}), nil
}

func NewAdminServiceHandler(
	oeu *usecase.OpenEntryUsecase,
	ceu *usecase.CloseEntryUsecase,
	ruu *usecase.RejectUserUsecase,
	ctu *usecase.ChangeTeamUsecase,
	asqu *usecase.AdminStartQuestUsecase,
	cau *usecase.CheckAnswersUsecase,
	nqu *usecase.NextQuizUsecase,
	equ *usecase.EndQuestUsecase,
) *AdminServiceHandler {
	return &AdminServiceHandler{
		oeu:  oeu,
		ceu:  ceu,
		ruu:  ruu,
		ctu:  ctu,
		asqu: asqu,
		cau:  cau,
		nqu:  nqu,
		equ:  equ,
	}
}
