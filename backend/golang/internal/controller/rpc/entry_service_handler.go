package controller

import (
	"context"

	entryv1 "github.com/itsuabush1003/cursed-frame/backend/golang/internal/gen/entry/v1"        // generated by protoc-gen-go
	"github.com/itsuabush1003/cursed-frame/backend/golang/internal/gen/entry/v1/entryv1connect" // generated by protoc-gen-connect-go

	"connectrpc.com/connect"

	"github.com/itsuabush1003/cursed-frame/backend/golang/internal/usecase"
)

type EntryServiceHandler struct {
	entryv1connect.UnimplementedEntryServiceHandler
	eu *usecase.EntryUsecase
	ru *usecase.ReconnectUsecase
	secret string
}

func (esh *EntryServiceHandler) Entry(
	_ context.Context, req *connect.Request[entryv1.EntryRequest],
) (*connect.Response[entryv1.EntryResponse], error) {
	userDto, err := esh.eu.Execute(req.Msg.UserName)
	if err != nil {
		return nil, err
	}
	res := connect.NewResponse(&entryv1.EntryResponse{
		UserId:      userDto.UserID.String(),
		AccessToken: userDto.AccessToken,
		Secret:      esh.secret,
	})
	return res, nil
}

func (esh *EntryServiceHandler) Reconnect(
	_ context.Context, req *connect.Request[entryv1.ReconnectRequest],
) (*connect.Response[entryv1.ReconnectResponse], error) {
	token, err := esh.ru.Execute(req.Msg.UserId, req.Msg.Secret)
	if err != nil {
		return nil, err
	}
	res := connect.NewResponse(&entryv1.ReconnectResponse{
		AccessToken: token,
	})
	return res, nil
}

func NewEntryServiceHandler(eu *usecase.EntryUsecase, ru *usecase.ReconnectUsecase, secret string) *EntryServiceHandler {
	return &EntryServiceHandler{
		eu: eu,
		ru: ru,
		secret: secret,
	}
}
