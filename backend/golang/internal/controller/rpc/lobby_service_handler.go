package controller

import (
	"context"
	"errors"

	lobbyv1 "github.com/itsuabush1003/cursed-frame/backend/golang/internal/gen/lobby/v1"        // generated by protoc-gen-go
	"github.com/itsuabush1003/cursed-frame/backend/golang/internal/gen/lobby/v1/lobbyv1connect" // generated by protoc-gen-connect-go
	"google.golang.org/protobuf/types/known/emptypb"

	"connectrpc.com/connect"

	"github.com/itsuabush1003/cursed-frame/backend/golang/internal/controller/middleware"
	"github.com/itsuabush1003/cursed-frame/backend/golang/internal/usecase"
)

type LobbyServiceHandler struct {
	lobbyv1connect.UnimplementedLobbyServiceHandler
	jlu *usecase.JoinLobbyUsecase
	rpu *usecase.RegistProfileUsecase
	sru *usecase.SetReadyUsecase
	gtu *usecase.GetTeamIDUsecase
}

func (lsh *LobbyServiceHandler) JoinLobby(ctx context.Context, r *connect.Request[emptypb.Empty], stream *connect.ServerStream[lobbyv1.LobbyStatus]) error {
	user := middleware.GetUserFromCtx(ctx)
	if user == nil {
		return connect.NewError(connect.CodeUnauthenticated, errors.New("Unauthenticated Access"))
	}

	return lsh.jlu.Execute(
		ctx, user.GetUserID(),
		func() error {
			return stream.Send(&lobbyv1.LobbyStatus{
				IsAllReady: false,
			})
		},
		func() {
			stream.Send(&lobbyv1.LobbyStatus{
				IsAllReady: true,
			})
		},
		func(err error) error {
			return connect.NewError(connect.CodeCanceled, err)
		},
	)
}

func (lsh *LobbyServiceHandler) RegistProfile(ctx context.Context, r *connect.Request[lobbyv1.RegistProfileRequest]) (*connect.Response[lobbyv1.RegistProfileResponse], error) {
	user := middleware.GetUserFromCtx(ctx)
	if user == nil {
		return nil, connect.NewError(connect.CodeUnauthenticated, errors.New("Unauthenticated Access"))
	}
	nextQuestion, err := lsh.rpu.Execute(usecase.UserProfileDTO{
		UserID:    user.GetUserID(),
		ProfileID: uint(r.Msg.QuestionId),
		Answer:    r.Msg.Answer,
	})
	if err != nil {
		return nil, connect.NewError(connect.CodeInvalidArgument, err)
	}
	res := connect.NewResponse(&lobbyv1.RegistProfileResponse{
		NextQuestionId:   uint32(nextQuestion.QuestionID),
		NextQuestionText: nextQuestion.QuestionText,
		NoMoreAnswer:     nextQuestion.NoMoreAnswer,
	})
	return res, nil
}

func (lsh *LobbyServiceHandler) IsReady(ctx context.Context, r *connect.Request[emptypb.Empty]) (*connect.Response[emptypb.Empty], error) {
	user := middleware.GetUserFromCtx(ctx)
	if user == nil {
		return nil, connect.NewError(connect.CodeUnauthenticated, errors.New("Unauthenticated Access"))
	}
	err := lsh.sru.Execute(user)
	if err != nil {
		return nil, connect.NewError(connect.CodeUnknown, err)
	}
	res := connect.NewResponse(&emptypb.Empty{})
	return res, nil
}

func (lsh *LobbyServiceHandler) GetTeamID(ctx context.Context, r *connect.Request[emptypb.Empty]) (*connect.Response[lobbyv1.GetTeamIDResponse], error) {
	user := middleware.GetUserFromCtx(ctx)
	if user == nil {
		return nil, connect.NewError(connect.CodeUnauthenticated, errors.New("Unauthenticated Access"))
	}
	tid, name, err := lsh.gtu.Execute(user)
	if err != nil {
		return nil, connect.NewError(connect.CodeInvalidArgument, err)
	}

	return connect.NewResponse(&lobbyv1.GetTeamIDResponse{TeamId: tid, TeamName: name}), nil
}

func NewLobbyServiceHandler(jlu *usecase.JoinLobbyUsecase, rpu *usecase.RegistProfileUsecase, sru *usecase.SetReadyUsecase, gtu *usecase.GetTeamIDUsecase) *LobbyServiceHandler {
	return &LobbyServiceHandler{
		jlu: jlu,
		rpu: rpu,
		sru: sru,
		gtu: gtu,
	}
}
